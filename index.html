<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="css/style.css">
    <title>Document</title>
</head>
<body>
    </div id="container">
        <div id="health-bar"><b>Health:</b></div>
        <div id="wave-bar"><b></b></div>
        <div id="wave-box"></div>
        <div id="score-bar"></div>
    </div>
    <script src="simple.js">
        /*Huvudloopen*/
        let amount = 3;
        let enemies = [];
        // Startpositioner för spelare
        let playerx = totalWidth/2;
        let playery = totalHeight/2 -120;
        let playerHealth = 100;
        let maxSpeed = 5;
        let playerSpeed = 2;
        let playerImg = "img/player.png";
        let wallColour = "grey";
        let score = -100;
        let bullets = [];
        let bulletSpeed = 10;
        // Lista för att spara position av muspekare när man skjuter. 
        let targetPos = []; 
        // Cooldown för att zombie ska kunna göra skada. 
        let coolDown = 100;
        let coolDownCnt = 0;
        // Cooldown för att skjuta skott. 
        let bulletCoolDown = 10;
        let bulletCoolDownCnt = 0;
        let bulletDamage = 10;
        // Variabel för att skriva ut vilken wave man är på. 
        let wave = 0;
        let dirx = 1;
        let diry = 1;
        let crosshairXX = mouse.x-17/2;
        let crosshairXY = mouse.y;
        let crosshairYX = mouse.x; 
        let crosshairYY = mouse.y-17/2;
        let crosshairCnt = 0;
        // Position för väggar
        let walls = [[totalWidth-10, 0, 40, totalHeight, wallColour],
                    [0, 0, totalWidth, 10, wallColour], 
                    [0, 0, 10, totalHeight, wallColour],
                    [0, totalHeight-10, totalWidth, 40, wallColour], 
                    [300, totalHeight/2, 1200, 20, wallColour], 
                    [(totalWidth/7), totalHeight/5, 120, 20, wallColour], 
                    [(totalWidth/7), totalHeight/5, 20, 120, wallColour],
                    [totalWidth-(totalWidth/7), totalHeight-(totalHeight/5)-20, 120, 20, wallColour],
                    [totalWidth-(totalWidth/7)+100, totalHeight-(totalHeight/5)-120, 20, 120, wallColour]];
        // Position för medkits
        let medPos = [[310, 230], [1690, 710]];

        function writeWave(wave)
        {
            let i = 254;
            dir = -1;
            let writingDone = false;
            documet.querySelector("#wave-box").style.display="flex;"
            document.querySelector("#wave-box").innerHTML="Wave: "+wave;
            while(!writingDone)
            {   
                if(i==0)
                {
                    dir=1;
                }
                document.querySelector("#wave-box").style.color="black;";
                if(i<255)
                {
                    i+=dir;
                }
            }
 
            document.querySelector("#wave-box").style.display = "none;";
        }

        function createEnemies(amount)
        {
            enemyList = [];
            for(let i=0; i < amount; i++)
            {
                enemyList.push({x: (totalWidth-30)*random(0, 1)+30, y: random(20, totalHeight-20), speed: random(0.8, 1), health: 100});
            }
            
            return enemyList;
        }

        // Funktion som kollar om ett objekt kolliderar med vägg. Returnerar en lista med fyra bools [upp, ner, höger, vänster]
        function detectCollision(x, y, objectType)
        {
            let objectFix = [0, 0, 0, 0]
            if(objectType == "player")
            {
                objectFix = [22, 80, 10, 10];
            }
            let availableMoves = [true, true, true, true];
            let collideDistance = 25;
            if(objectType == "projectile")
            {
                collideDistance = 5;
            }
            for(let i=0;i<walls.length;i++)
            {
                if(Math.max(walls[i][0], x) - Math.min(walls[i][0], x) < collideDistance && y < walls[i][1] + walls[i][3] && y > walls[i][1])
                {
                    availableMoves[2] = false;
                }
                 
                if(Math.max(walls[i][0]+walls[i][2], x) - Math.min(walls[i][0]+walls[i][2], x) < collideDistance && y < walls[i][1] + walls[i][3] && y > walls[i][1])
                {
                    availableMoves[3] = false;
                }
                if(Math.max(walls[i][1]+walls[i][3], y+objectFix[0]) - Math.min(walls[i][1]+walls[i][3], y+objectFix[0]) < collideDistance && x < walls[i][0] + walls[i][2] && x > walls[i][0])
                {
                    availableMoves[0] = false;
                }
                if(Math.max(walls[i][1], y+objectFix[1]) - Math.min(walls[i][1], y+objectFix[1]) < collideDistance && x < walls[i][0] + walls[i][2] && x > walls[i][0])
                {
                    availableMoves[1] = false;
                }
            }
            return availableMoves;
        }

        function update()
        {
            clearScreen();
            text(10, 10, 10, "test"+score, "rgb(0, 0, 0)")
            document.querySelector("#score-bar").innerHTML='<b>Score: '+score+'</b>';
            document.querySelector("#wave-bar").innerHTML='<b>Wave: '+wave+'</b>';
            if(enemies.length == 0)
            {
                score+=100;
                amount+=2;
                wave+=1;
                enemies = createEnemies(amount);
                text(200, totalHeight/2, 20, "wave" +wave, "black");
            }
            // Rör på fiender
            for(let i=0;i<enemies.length;i++)
            {
                if(enemies[i].health != 0)
                {
                    picture(enemies[i].x, enemies[i].y, "img/zombie.png");
                }
                let availableMoves = detectCollision(enemies[i].x, enemies[i].y, "player");
                if(!availableMoves[0] || !availableMoves[1])
                {
                    if(enemies[i].x < totalWidth/2)
                    {
                        enemies[i].x -= enemies[i].speed;
                    }
                    if(enemies[i].x > totalWidth/2)
                    {
                        enemies[i].x += enemies[i].speed;
                    }
                }
                /*
                if(!availableMoves[2] || !availableMoves[3])
                {
                    if(enemies[i].y < playery)
                    {
                        enemies[i].y -= enemies[i].speed;
                    }
                    if(enemies[i].y > playery)
                    {
                        enemies[i].y += enemies[i].speed;
                    }
                }*/
                else if(enemies[i].x < playerx && availableMoves[2])
                {
                    enemies[i].x+=enemies[i].speed;
                }
                else if(availableMoves[3] && enemies[i].x > playerx)
                {
                    enemies[i].x-=enemies[i].speed;
                }
                if(enemies[i].y < playery && availableMoves[1])
                {
                    enemies[i].y+=enemies[i].speed;
                }
                if(enemies[i].y > playery && availableMoves[0])
                {
                    enemies[i].y-=enemies[i].speed;
                }

                // Health bar för fiender 10px över huvudet 
                rectangle(enemies[i].x, enemies[i].y-10, 80, 3, "black");
                rectangle(enemies[i].x, enemies[i].y-10, 80*(enemies[i].health/100), 3, "rgb(0, 255, 0)");

                if(distance(enemies[i].x, enemies[i].y+40, playerx, playery) < 40 && coolDownCnt == 0)
                {
                    playerHealth-=10;
                    if(playerHealth < 0)
                    {
                        playerHealth=0;
                    }
                }
                if(enemies[i].health <= 0)
                {
                    let bruh = new Audio("audio/bruh.mp3");
                    bruh.play();
                    // Om man dödar en fiende ökar score med 10 poäng. 
                    score+=10;
                    let zombieChange = enemies[i];
                    enemies[i] = enemies[enemies.length-1];
                    enemies[enemies.length-1] = zombieChange;
                    enemies.pop(); 
                }
            }

            rectangle(100, 20, 150, 15, "black");
            rectangle(100, 20, 150*(playerHealth/100), 15, "rgb(0, 255, 0)");
            picture(playerx, playery, playerImg);
            // Crosshair
            rectangle(crosshairXX, crosshairXY, 20, 3, "rgb(0, 255, 255)");
            rectangle(crosshairYX, crosshairYY, 3, 20, "rgb(0, 255, 255)"); 
            
            let checked = [false, false, false, false];
            // Väggar i kartan
            for(let i=0; i<walls.length;i++) 
            {
                rectangle(walls[i][0], walls[i][1], walls[i][2], walls[i][3], walls[i][4]);
            } 

            // Kolla om spelare kolliderar med vägg
            let availableMoves = detectCollision(playerx+30, playery, "player");

            if(keyboard.w && availableMoves[0])
            {
                playery-=playerSpeed;
            }
            if(keyboard.s && availableMoves[1])
            {
                playery+=playerSpeed;
            }
            if(keyboard.d && availableMoves[2])
            {
                playerx+=playerSpeed;
                playerImg = "img/player2.png";
            }
            if(keyboard.a && availableMoves[3])
            {
                playerx-=playerSpeed;
                playerImg = "img/player.png";
            }
            
            if(keyboard.space && bulletCoolDownCnt == 0)
            {
                bulletCoolDownCnt+=1;
                crosshairXX = mouse.x-17/2 +30;
                crosshairXY = mouse.y+30;
                crosshairYX = mouse.x-30; 
                crosshairYY = mouse.y-17/2-30;
                let bulletSound = new Audio("audio/gunshot.mp3");
                bulletSound.play();
                bulletCoolDownCnt+=1;
                bullets.push([playerx, playery+30]);
                dirx = 1; 
                diry = 1;
                if(mouse.x < playerx)
                {
                    // Om muspekare är till vänster om spelaren ska x-riktningen bli negativ (projektilen ska röra sig åt vänster)
                    dirx = -1;
                }
                if(mouse.y < playery)
                {
                    // Om muspekare är över spelaren ska y-riktningen bli negativ (projektilen ska röra sig uppåt) 
                    diry = -1
                }
                let i = bullets.length-1;
                let distancex = Math.max(bullets[i][0], mouse.x) - Math.min(bullets[i][0], mouse.x);
                let distancey = Math.max(bullets[i][1], mouse.y) - Math.min(bullets[i][1], mouse.y);
                // Det vi vill är att x och y positionen ska ta så stora steg så att kommer till slutpunkten samtidigt 
                distancey = distancey/distancex;
                distancex = 1;
                targetPos.push([distancex*dirx, distancey*diry]); 
            }

            for(let i=0;i<bullets.length;i++)
            {
                    // Räkna ut hur många pixlar projektilen ska ändras för varje uppdatering 
                    bullets[i][0] += bulletSpeed * targetPos[i][0]; 
                    bullets[i][1] += bulletSpeed * targetPos[i][1];
                    circle(bullets[i][0], bullets[i][1], 3, "black");
                    for(let j=0;j<enemies.length;j++)
                    {
                        if(distance(enemies[j].x, enemies[j].y+40, bullets[i][0], bullets[i][1]) < 60)
                        {
                            enemies[j].health -= bulletDamage;
                            // Om en projektil träffar en fiende så byter vi endast plats på koordinaterna och efter denna for-loopen tar vi bort dem från listan
                            bullets[i][0] = 10000; 
                            bullets[i][1] = 10000;
                        }
                    }
                    if(bullets[i][0] > totalWidth || bullets[i][1] > totalHeight || bullets[i][0] < 0 || bullets[i][1] < 0 || detectCollision(bullets[i][0], bullets[i][1], "projectile").includes(false))
                    {
                            // Ta bort projektil från lista om den är utanför kartan (eller om den träffat en fiende eller vägg)
                            let change = bullets[i];
                            let change2 = targetPos[i];
                            bullets[i] = bullets[bullets.length-1];
                            bullets[bullets.length-1] = change;
                            bullets.pop();
                            targetPos[i] = targetPos[targetPos.length-1];
                            targetPos[targetPos.length-1] = change2;
                            targetPos.pop();
                    }
            }
            

            for(let i=0;i<medPos.length;i++)
            {
                circle(medPos[i][0], medPos[i][1], 10, "red");
                if(distance(playerx, playery, medPos[i][0], medPos[i][1]) < 30 && playerHealth < 100)
                {
                    playerHealth=100;
                    medPos[i][0] = 10000;
                    medPos[i][1] = 10000;
                }
            }

            if (crosshairXX != mouse.x-(17/2))
            {
                crosshairCnt+=1;
                crosshairXX = mouse.x-17/2 +30-crosshairCnt;
                crosshairXY = mouse.y+30-crosshairCnt;
                crosshairYX = mouse.x-30+crosshairCnt; 
                crosshairYY = mouse.y-17/2-30+crosshairCnt;
            }
            if(crosshairCnt == 30)
            {
                crosshairCnt = 0;
            }

            coolDownCnt+=1;
            if(bulletCoolDownCnt > 0)
            {
                bulletCoolDownCnt+=1;
            }
            if(coolDownCnt == coolDown)
            {
                coolDownCnt=0;
            }

            if(bulletCoolDownCnt == bulletCoolDown)
            {
                bulletCoolDownCnt = 0; 
            }
        }
    </script>
</body>
</html>